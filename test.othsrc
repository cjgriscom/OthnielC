//TODO check for valid pipe names and method names

import{"test_methods"}
alias{"test_shiftregister:stringRegister", shiftRegister}
variable <global1:string="content">
constant <DEFAULT_REG:string="emptyRegister">

instantiated sequence [a:numeric,b:numeric]test <arbitraryThing:I32(1)=<1,1>>
	
    //[3]dim{I32(1)}[pizzaToppings]                               // Create a string array of 3 elements
	[pizzaToppings, 0,"pepperoni", 1,"sausage", 2,"shrooms"]set // sets indices 0-2
	[pizzaToppings]length[len] [len, " Toppings: "]PRINT        // Prints “3 Toppings: ”
	[pizzaToppings,0,1,2]index[>,>,>] [<, " ", <, " ", <]PRINT  // Prints “pepperoni sausage shrooms”
	
	["1st pass:"]PRINT ["1st message"]shiftRegister[>]PRINTLN
	["2nd pass:"]PRINT [?]shiftRegister[>]PRINTLN
	["3rd pass:"]PRINT [?]shiftRegister[>]PRINTLN
	["4th pass:"]PRINT ["4th message"]shiftRegister[>]PRINTLN
	["5th pass:"]PRINT [?]shiftRegister[>]PRINTLN
	
	[true]:[someBoolean]
	[12]:[a]
	
	EXECUTE{[a]++[a]:[>] ["EXECUTE: ", <, " is the new value of a"]PRINTLN}
	EXECUTE{EXECUTE{[a]++[a] ["EXECUTE^2: ", a, " is the new value of a"]PRINTLN}}
	["Main: a=", a]PRINTLN
	
	EXECUTE{
		["Enter value for hidden var: "]PRINT
		INPUT{string}[hiddenVar]
		["234"]:[hiddenVar]
		["Value of hidden var in execute scope is: ", hiddenVar]PRINTLN
	}
	
	#PIPEEXISTS{a}[>] [<, "exists!", "does not exist."]?:[>] ["a ", <]PRINTLN
	#PIPEEXISTS{hiddenVar}[>] [<, "exists!", "does not exist."]?:[>] ["hiddenVar ", <]PRINTLN
	
	//if{ [a,11]>=[con1] [a,12]<=[con2] [con1, con2]AND[r]}: // {statements}
	//	[true]:[result]
	//:[someBoolean]elseif:
	//	[false]:[result]
	//:end[result]	//'if' is a compound block; anything piped out through end[] must be defined in each part of the block
	
	//[result]PRINTLN
	
	//[a]select:
	//	case
	//:end
	
	sequence:
		[42]:[theAnswer]	
	:end[theAnswer]
	[theAnswer]PRINTLN
	
	[true, 50]var0[^] [false, ?]var0[>]PRINTLN
	[true, 51]var1[^] [false, 0]var1[>]PRINTLN
	[true, 52]var2[^] [false, 0]var2[>]PRINTLN
	[true, 53]var3[^] [false, 0]var3[>]PRINTLN
	[true, 54]var4[^] [true, 54.5]var4Double[^] [false, 0]var4[out1] [false, 0]var4Double[>] [out1, ", ", <]PRINTLN
	[true, 55]var5[^] [false, 0]var5[>]PRINTLN

	getDefault[>] ["Default: ", <]PRINTLN
	
	["Enter two booleans (0 or 1): "]PRINT
	INPUT{I8}[>]  [<, 1]=[bool1]
	INPUT{I8}[>]  [<, 1]=[bool2]
	[bool1, bool2]printBooleanOps
	
	["Enter two ints: "]PRINT
	INPUT{I32}[int1] INPUT{I32}[int2]
	[int1,int2]SWAP[int1,int2]
	[int1, "+", int2, "="]PRINT [int1, int2]+[>]PRINTLN
	[int1, "-", int2, "="]PRINT [int1, int2]-[>]PRINTLN
	[int1, "*", int2, "="]PRINT [int1, int2]*[>]PRINTLN
	[int1, "/", int2, "="]PRINT [int1, int2]/[>]PRINTLN
	[int1, "%", int2, "="]PRINT [int1, int2]%[>]PRINTLN
	[int1, "=", int2, "?  "]PRINT [int1, int2]=[>]PRINTLN
	[int1, "!=", int2, "? "]PRINT [int1, int2]!=[>]PRINTLN
	[int1, ">", int2, "?  "]PRINT [int1, int2]>[>]PRINTLN
	[int1, "<", int2, "?  "]PRINT [int1, int2]<[>]PRINTLN
	[int1, ">=", int2, "? "]PRINT [int1, int2]>=[>]PRINTLN
	[int1, "<=", int2, "? "]PRINT [int1, int2]<=[>]PRINTLN
	["Min,max of ", int1, " and ", int2, ": "]PRINT [int1,int2]MINMAX[>, >] [<, ",", <]PRINTLN
	["Min of ", int1, " and ", int2, ": "]PRINT [int1,int2]MINMAX[>, ^] [<]PRINTLN
	["Max of ", int1, " and ", int2, ": "]PRINT [int1,int2]MINMAX[^, >]PRINTLN

static sequence [bool1:boolean,bool2:boolean]printBooleanOps
	[bool1, bool2]XOR[>]  ["Result of XOR:  ", <]PRINTLN
	[bool1, bool2]AND[>]  ["Result of AND:  ", <]PRINTLN
	[bool1, bool2]OR[>]   ["Result of OR:   ", <]PRINTLN
	[bool1, bool2]XNOR[>] ["Result of XNOR: ", <]PRINTLN
	[bool1, bool2]NAND[>] ["Result of NAND: ", <]PRINTLN
	[bool1, bool2]NOR[>]  ["Result of NOR:  ", <]PRINTLN

instantiated sequence [a:anything, b:typeof(a)]SWAP[newA:typeof(a), newB:typeof(a)]
	[a]:[newB] [b]:[newA]
